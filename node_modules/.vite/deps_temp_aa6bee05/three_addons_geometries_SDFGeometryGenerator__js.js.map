{
  "version": 3,
  "sources": ["../../three/examples/jsm/libs/surfaceNet.js", "../../three/examples/jsm/geometries/SDFGeometryGenerator.js"],
  "sourcesContent": ["/**\n * SurfaceNets in JavaScript\n *\n * Written by Mikola Lysenko (C) 2012\n *\n * MIT License\n *\n * Based on: S.F. Gibson, 'Constrained Elastic Surface Nets'. (1998) MERL Tech Report.\n * from https://github.com/mikolalysenko/isosurface/tree/master\n * \n */\n\nlet surfaceNet = ( dims, potential, bounds ) => {\n\t\t\n\t\n\t//Precompute edge table, like Paul Bourke does.\n\t// This saves a bit of time when computing the centroid of each boundary cell\n\tvar cube_edges = new Int32Array(24) , edge_table = new Int32Array(256);\n\t(function() {\n\n\t\t//Initialize the cube_edges table\n\t\t// This is just the vertex number of each cube\n\t\tvar k = 0;\n\t\tfor(var i=0; i<8; ++i) {\n\t\t\tfor(var j=1; j<=4; j<<=1) {\n\t\t\t\tvar p = i^j;\n\t\t\t\tif(i <= p) {\n\t\t\t\t\tcube_edges[k++] = i;\n\t\t\t\t\tcube_edges[k++] = p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//Initialize the intersection table.\n\t\t//  This is a 2^(cube configuration) ->  2^(edge configuration) map\n\t\t//  There is one entry for each possible cube configuration, and the output is a 12-bit vector enumerating all edges crossing the 0-level.\n\t\tfor(var i=0; i<256; ++i) {\n\t\t\tvar em = 0;\n\t\t\tfor(var j=0; j<24; j+=2) {\n\t\t\t\tvar a = !!(i & (1<<cube_edges[j]))\n\t\t\t\t\t, b = !!(i & (1<<cube_edges[j+1]));\n\t\t\t\tem |= a !== b ? (1 << (j >> 1)) : 0;\n\t\t\t}\n\t\t\tedge_table[i] = em;\n\t\t}\n\t})();\n\n\t//Internal buffer, this may get resized at run time\n\tvar buffer = new Array(4096);\n\t(function() {\n\t\tfor(var i=0; i<buffer.length; ++i) {\n\t\t\tbuffer[i] = 0;\n\t\t}\n\t})();\n\n\tif(!bounds) {\n\t\tbounds = [[0,0,0],dims];\n\t}\n\t\n\tvar scale     = [0,0,0];\n\tvar shift     = [0,0,0];\n\tfor(var i=0; i<3; ++i) {\n\t\tscale[i] = (bounds[1][i] - bounds[0][i]) / dims[i];\n\t\tshift[i] = bounds[0][i];\n\t}\n\t\n\tvar vertices = []\n\t\t, faces = []\n\t\t, n = 0\n\t\t, x = [0, 0, 0]\n\t\t, R = [1, (dims[0]+1), (dims[0]+1)*(dims[1]+1)]\n\t\t, grid = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n\t\t, buf_no = 1;\n\t\n\t\t\n\t//Resize buffer if necessary \n\tif(R[2] * 2 > buffer.length) {\n\t\tvar ol = buffer.length;\n\t\tbuffer.length = R[2] * 2;\n\t\twhile(ol < buffer.length) {\n\t\t\tbuffer[ol++] = 0;\n\t\t}\n\t}\n\t\n\t//March over the voxel grid\n\tfor(x[2]=0; x[2]<dims[2]-1; ++x[2], n+=dims[0], buf_no ^= 1, R[2]=-R[2]) {\n\t\n\t\t//m is the pointer into the buffer we are going to use.  \n\t\t//This is slightly obtuse because javascript does not have good support for packed data structures, so we must use typed arrays :(\n\t\t//The contents of the buffer will be the indices of the vertices on the previous x/y slice of the volume\n\t\tvar m = 1 + (dims[0]+1) * (1 + buf_no * (dims[1]+1));\n\t\t\n\t\tfor(x[1]=0; x[1]<dims[1]-1; ++x[1], ++n, m+=2)\n\t\tfor(x[0]=0; x[0]<dims[0]-1; ++x[0], ++n, ++m) {\n\t\t\n\t\t\t//Read in 8 field values around this vertex and store them in an array\n\t\t\t//Also calculate 8-bit mask, like in marching cubes, so we can speed up sign checks later\n\t\t\tvar mask = 0, g = 0;\n\t\t\tfor(var k=0; k<2; ++k)\n\t\t\tfor(var j=0; j<2; ++j)      \n\t\t\tfor(var i=0; i<2; ++i, ++g) {\n\t\t\t\tvar p = potential(\n\t\t\t\t\tscale[0]*(x[0]+i)+shift[0],\n\t\t\t\t\tscale[1]*(x[1]+j)+shift[1],\n\t\t\t\t\tscale[2]*(x[2]+k)+shift[2]);\n\t\t\t\tgrid[g] = p;\n\t\t\t\tmask |= (p < 0) ? (1<<g) : 0;\n\t\t\t}\n\t\t\t\n\t\t\t//Check for early termination if cell does not intersect boundary\n\t\t\tif(mask === 0 || mask === 0xff) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t//Sum up edge intersections\n\t\t\tvar edge_mask = edge_table[mask]\n\t\t\t\t, v = [0.0,0.0,0.0]\n\t\t\t\t, e_count = 0;\n\t\t\t\t\n\t\t\t//For every edge of the cube...\n\t\t\tfor(var i=0; i<12; ++i) {\n\t\t\t\n\t\t\t\t//Use edge mask to check if it is crossed\n\t\t\t\tif(!(edge_mask & (1<<i))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//If it did, increment number of edge crossings\n\t\t\t\t++e_count;\n\t\t\t\t\n\t\t\t\t//Now find the point of intersection\n\t\t\t\tvar e0 = cube_edges[ i<<1 ]       //Unpack vertices\n\t\t\t\t\t, e1 = cube_edges[(i<<1)+1]\n\t\t\t\t\t, g0 = grid[e0]                 //Unpack grid values\n\t\t\t\t\t, g1 = grid[e1]\n\t\t\t\t\t, t  = g0 - g1;                 //Compute point of intersection\n\t\t\t\tif(Math.abs(t) > 1e-6) {\n\t\t\t\t\tt = g0 / t;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//Interpolate vertices and add up intersections (this can be done without multiplying)\n\t\t\t\tfor(var j=0, k=1; j<3; ++j, k<<=1) {\n\t\t\t\t\tvar a = e0 & k\n\t\t\t\t\t\t, b = e1 & k;\n\t\t\t\t\tif(a !== b) {\n\t\t\t\t\t\tv[j] += a ? 1.0 - t : t;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv[j] += a ? 1.0 : 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//Now we just average the edge intersections and add them to coordinate\n\t\t\tvar s = 1.0 / e_count;\n\t\t\tfor(var i=0; i<3; ++i) {\n\t\t\t\tv[i] = scale[i] * (x[i] + s * v[i]) + shift[i];\n\t\t\t}\n\t\t\t\n\t\t\t//Add vertex to buffer, store pointer to vertex index in buffer\n\t\t\tbuffer[m] = vertices.length;\n\t\t\tvertices.push(v);\n\t\t\t\n\t\t\t//Now we need to add faces together, to do this we just loop over 3 basis components\n\t\t\tfor(var i=0; i<3; ++i) {\n\t\t\t\t//The first three entries of the edge_mask count the crossings along the edge\n\t\t\t\tif(!(edge_mask & (1<<i)) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// i = axes we are point along.  iu, iv = orthogonal axes\n\t\t\t\tvar iu = (i+1)%3\n\t\t\t\t\t, iv = (i+2)%3;\n\t\t\t\t\t\n\t\t\t\t//If we are on a boundary, skip it\n\t\t\t\tif(x[iu] === 0 || x[iv] === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//Otherwise, look up adjacent edges in buffer\n\t\t\t\tvar du = R[iu]\n\t\t\t\t\t, dv = R[iv];\n\t\t\t\t\n\t\t\t\t//Remember to flip orientation depending on the sign of the corner.\n\t\t\t\tif(mask & 1) {\n\t\t\t\t\tfaces.push([buffer[m],    buffer[m-du],    buffer[m-dv]]);\n\t\t\t\t\tfaces.push([buffer[m-dv], buffer[m-du],    buffer[m-du-dv]]);\n\t\t\t\t} else {\n\t\t\t\t\tfaces.push([buffer[m],    buffer[m-dv],    buffer[m-du]]);\n\t\t\t\t\tfaces.push([buffer[m-du], buffer[m-dv],    buffer[m-du-dv]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//All done!  Return the result\n\treturn { positions: vertices, cells: faces };\n}\n\nexport { surfaceNet }", "/**\n * @author santiago / @glitch_life\n * wrapper of https://www.npmjs.com/package/isosurface by https://github.com/mikolalysenko\n *\n * Returns BufferGeometry from SDF\n */\n\nimport {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloatType,\n\tMesh,\n\tOrthographicCamera,\n\tPlaneGeometry,\n\tScene,\n\tShaderMaterial,\n\tVector2,\n\tWebGLRenderTarget\n} from 'three';\n\nimport { surfaceNet } from './../libs/surfaceNet.js';\n\nclass SDFGeometryGenerator {\n\n\tconstructor( renderer ) {\n\n\t\tthis.renderer = renderer;\n\n\t}\n\n\tgenerate( res = 64, distFunc = 'float dist( vec3 p ){ return length(p) - 0.5; }', bounds = 1 ) {\n\n\t\tlet w, h;\n\t\tif ( res == 8 ) [ w, h ] = [ 32, 16 ];\n\t\telse if ( res == 16 ) [ w, h ] = [ 64, 64 ];\n\t\telse if ( res == 32 ) [ w, h ] = [ 256, 128 ];\n\t\telse if ( res == 64 ) [ w, h ] = [ 512, 512 ];\n\t\telse if ( res == 128 ) [ w, h ] = [ 2048, 1024 ];\n\t\telse if ( res == 256 ) [ w, h ] = [ 4096, 4096 ];\n\t\telse if ( res == 512 ) [ w, h ] = [ 16384, 8096 ];\n\t\telse if ( res == 1024 ) [ w, h ] = [ 32768, 32768 ];\n\t\telse throw new Error( 'THREE.SDFGeometryGenerator: Resolution must be in range 8 < res < 1024 and must be ^2' );\n\n\t\tconst maxTexSize = this.renderer.capabilities.maxTextureSize;\n\n\t\tif ( w > maxTexSize || h > maxTexSize ) throw new Error( 'THREE.SDFGeometryGenerator: Your device does not support this resolution ( ' + res + ' ), decrease [res] param.' );\n\n\t\tconst [ tilesX, tilesY ] = [ ( w / res ), ( h / res ) ];\n\n\t\tconst sdfCompute = `\n\t\t\tvarying vec2 vUv;\n\t\t\tuniform float tileNum;\n\t\t\tuniform float bounds;\n\t\t\t[#dist#]\n\t\t\tvoid main()\t{ gl_FragColor=vec4( ( dist( vec3( vUv, tileNum ) * 2.0 * bounds - vec3( bounds ) ) < 0.00001 ) ? 1.0 : 0.0 ); }\n\t\t`;\n\n\t\tconst sdfRT = this.computeSDF( w, h, tilesX, tilesY, bounds, sdfCompute.replace( '[#dist#]', distFunc ) );\n\n\t\tconst read = new Float32Array( w * h * 4 );\n\t\tthis.renderer.readRenderTargetPixels( sdfRT, 0, 0, w, h, read );\n\t\tsdfRT.dispose();\n\n\t\t//\n\n\t\tconst mesh = surfaceNet( [ res, res, res ], ( x, y, z ) => {\n\n\t\t\tx = ( x + bounds ) * ( res / ( bounds * 2 ) );\n\t\t\ty = ( y + bounds ) * ( res / ( bounds * 2 ) );\n\t\t\tz = ( z + bounds ) * ( res / ( bounds * 2 ) );\n\t\t\tlet p = ( x + ( z % tilesX ) * res ) + y * w + ( Math.floor( z / tilesX ) * res * w );\n\t\t\tp *= 4;\n\t\t\treturn ( read[ p + 3 ] > 0 ) ? - 0.000000001 : 1;\n\n\t\t}, [[ - bounds, - bounds, - bounds ], [ bounds, bounds, bounds ]] );\n\n\t\tconst ps = [], ids = [];\n\t\tconst geometry = new BufferGeometry();\n\t\tmesh.positions.forEach( p => {\n\n\t\t\tps.push( p[ 0 ], p[ 1 ], p[ 2 ] );\n\n\t\t} );\n\t\tmesh.cells.forEach( p => ids.push( p[ 0 ], p[ 1 ], p[ 2 ] ) );\n\t\tgeometry.setAttribute( 'position', new BufferAttribute( new Float32Array( ps ), 3 ) );\n\t\tgeometry.setIndex( ids );\n\n\t\treturn geometry;\n\n\t}\n\n\tcomputeSDF( width, height, tilesX, tilesY, bounds, shader ) {\n\n\t\tconst rt = new WebGLRenderTarget( width, height, { type: FloatType } );\n\t\tconst scn = new Scene();\n\t\tconst cam = new OrthographicCamera();\n\t\tconst tiles = tilesX * tilesY;\n\t\tlet currentTile = 0;\n\n\t\tObject.assign( cam, { left: width / - 2, right: width / 2, top: height / 2, bottom: height / - 2 } ).updateProjectionMatrix();\n\t\tcam.position.z = 2;\n\n\t\tconst tileSize = width / tilesX;\n\t\tconst geometry = new PlaneGeometry( tileSize, tileSize );\n\n\t\twhile ( currentTile ++ < tiles ) {\n\n\t\t\tconst c = currentTile - 1;\n\t\t\tconst [ px, py ] = [ ( tileSize ) / 2 + ( c % tilesX ) * ( tileSize ) - width / 2, ( tileSize ) / 2 + Math.floor( c / tilesX ) * ( tileSize ) - height / 2 ];\n\t\t\tconst compPlane = new Mesh( geometry, new ShaderMaterial( {\n\t\t\t\tuniforms: {\n\t\t\t\t\tres: { value: new Vector2( width, height ) },\n\t\t\t\t\ttileNum: { value: c / ( tilesX * tilesY - 1 ) },\n\t\t\t\t\tbounds: { value: bounds }\n\t\t\t\t},\n\t\t\t\tvertexShader: 'varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}',\n\t\t\t\tfragmentShader: shader\n\t\t\t} ) );\n\t\t\tcompPlane.position.set( px, py, 0 );\n\t\t\tscn.add( compPlane );\n\n\t\t}\n\n\t\tthis.renderer.setRenderTarget( rt );\n\t\tthis.renderer.render( scn, cam );\n\t\tthis.renderer.setRenderTarget( null );\n\n\t\t//\n\n\t\tgeometry.dispose();\n\n\t\tscn.traverse( function ( object ) {\n\n\t\t\tif ( object.material !== undefined ) object.material.dispose();\n\n\t\t} );\n\n\t\treturn rt;\n\n\t}\n\n}\n\nexport { SDFGeometryGenerator };\n"],
  "mappings": "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",
  "names": ["k", "i", "j", "p", "a", "b"]
}
