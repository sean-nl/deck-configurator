import {
  BufferAttribute,
  BufferGeometry,
  FloatType,
  Mesh,
  OrthographicCamera,
  PlaneGeometry,
  Scene,
  ShaderMaterial,
  Vector2,
  WebGLRenderTarget
} from "./chunk-3F2VCGLV.js";

// node_modules/three/examples/jsm/libs/surfaceNet.js
var surfaceNet = (dims, potential, bounds) => {
  var cube_edges = new Int32Array(24), edge_table = new Int32Array(256);
  (function() {
    var k2 = 0;
    for (var i2 = 0; i2 < 8; ++i2) {
      for (var j2 = 1; j2 <= 4; j2 <<= 1) {
        var p2 = i2 ^ j2;
        if (i2 <= p2) {
          cube_edges[k2++] = i2;
          cube_edges[k2++] = p2;
        }
      }
    }
    for (var i2 = 0; i2 < 256; ++i2) {
      var em = 0;
      for (var j2 = 0; j2 < 24; j2 += 2) {
        var a2 = !!(i2 & 1 << cube_edges[j2]), b2 = !!(i2 & 1 << cube_edges[j2 + 1]);
        em |= a2 !== b2 ? 1 << (j2 >> 1) : 0;
      }
      edge_table[i2] = em;
    }
  })();
  var buffer = new Array(4096);
  (function() {
    for (var i2 = 0; i2 < buffer.length; ++i2) {
      buffer[i2] = 0;
    }
  })();
  if (!bounds) {
    bounds = [[0, 0, 0], dims];
  }
  var scale = [0, 0, 0];
  var shift = [0, 0, 0];
  for (var i = 0; i < 3; ++i) {
    scale[i] = (bounds[1][i] - bounds[0][i]) / dims[i];
    shift[i] = bounds[0][i];
  }
  var vertices = [], faces = [], n = 0, x = [0, 0, 0], R = [1, dims[0] + 1, (dims[0] + 1) * (dims[1] + 1)], grid = [0, 0, 0, 0, 0, 0, 0, 0], buf_no = 1;
  if (R[2] * 2 > buffer.length) {
    var ol = buffer.length;
    buffer.length = R[2] * 2;
    while (ol < buffer.length) {
      buffer[ol++] = 0;
    }
  }
  for (x[2] = 0; x[2] < dims[2] - 1; ++x[2], n += dims[0], buf_no ^= 1, R[2] = -R[2]) {
    var m = 1 + (dims[0] + 1) * (1 + buf_no * (dims[1] + 1));
    for (x[1] = 0; x[1] < dims[1] - 1; ++x[1], ++n, m += 2)
      for (x[0] = 0; x[0] < dims[0] - 1; ++x[0], ++n, ++m) {
        var mask = 0, g = 0;
        for (var k = 0; k < 2; ++k)
          for (var j = 0; j < 2; ++j)
            for (var i = 0; i < 2; ++i, ++g) {
              var p = potential(
                scale[0] * (x[0] + i) + shift[0],
                scale[1] * (x[1] + j) + shift[1],
                scale[2] * (x[2] + k) + shift[2]
              );
              grid[g] = p;
              mask |= p < 0 ? 1 << g : 0;
            }
        if (mask === 0 || mask === 255) {
          continue;
        }
        var edge_mask = edge_table[mask], v = [0, 0, 0], e_count = 0;
        for (var i = 0; i < 12; ++i) {
          if (!(edge_mask & 1 << i)) {
            continue;
          }
          ++e_count;
          var e0 = cube_edges[i << 1], e1 = cube_edges[(i << 1) + 1], g0 = grid[e0], g1 = grid[e1], t = g0 - g1;
          if (Math.abs(t) > 1e-6) {
            t = g0 / t;
          } else {
            continue;
          }
          for (var j = 0, k = 1; j < 3; ++j, k <<= 1) {
            var a = e0 & k, b = e1 & k;
            if (a !== b) {
              v[j] += a ? 1 - t : t;
            } else {
              v[j] += a ? 1 : 0;
            }
          }
        }
        var s = 1 / e_count;
        for (var i = 0; i < 3; ++i) {
          v[i] = scale[i] * (x[i] + s * v[i]) + shift[i];
        }
        buffer[m] = vertices.length;
        vertices.push(v);
        for (var i = 0; i < 3; ++i) {
          if (!(edge_mask & 1 << i)) {
            continue;
          }
          var iu = (i + 1) % 3, iv = (i + 2) % 3;
          if (x[iu] === 0 || x[iv] === 0) {
            continue;
          }
          var du = R[iu], dv = R[iv];
          if (mask & 1) {
            faces.push([buffer[m], buffer[m - du], buffer[m - dv]]);
            faces.push([buffer[m - dv], buffer[m - du], buffer[m - du - dv]]);
          } else {
            faces.push([buffer[m], buffer[m - dv], buffer[m - du]]);
            faces.push([buffer[m - du], buffer[m - dv], buffer[m - du - dv]]);
          }
        }
      }
  }
  return { positions: vertices, cells: faces };
};

// node_modules/three/examples/jsm/geometries/SDFGeometryGenerator.js
var SDFGeometryGenerator = class {
  constructor(renderer) {
    this.renderer = renderer;
  }
  generate(res = 64, distFunc = "float dist( vec3 p ){ return length(p) - 0.5; }", bounds = 1) {
    let w, h;
    if (res == 8)
      [w, h] = [32, 16];
    else if (res == 16)
      [w, h] = [64, 64];
    else if (res == 32)
      [w, h] = [256, 128];
    else if (res == 64)
      [w, h] = [512, 512];
    else if (res == 128)
      [w, h] = [2048, 1024];
    else if (res == 256)
      [w, h] = [4096, 4096];
    else if (res == 512)
      [w, h] = [16384, 8096];
    else if (res == 1024)
      [w, h] = [32768, 32768];
    else
      throw new Error("THREE.SDFGeometryGenerator: Resolution must be in range 8 < res < 1024 and must be ^2");
    const maxTexSize = this.renderer.capabilities.maxTextureSize;
    if (w > maxTexSize || h > maxTexSize)
      throw new Error("THREE.SDFGeometryGenerator: Your device does not support this resolution ( " + res + " ), decrease [res] param.");
    const [tilesX, tilesY] = [w / res, h / res];
    const sdfCompute = `
			varying vec2 vUv;
			uniform float tileNum;
			uniform float bounds;
			[#dist#]
			void main()	{ gl_FragColor=vec4( ( dist( vec3( vUv, tileNum ) * 2.0 * bounds - vec3( bounds ) ) < 0.00001 ) ? 1.0 : 0.0 ); }
		`;
    const sdfRT = this.computeSDF(w, h, tilesX, tilesY, bounds, sdfCompute.replace("[#dist#]", distFunc));
    const read = new Float32Array(w * h * 4);
    this.renderer.readRenderTargetPixels(sdfRT, 0, 0, w, h, read);
    sdfRT.dispose();
    const mesh = surfaceNet([res, res, res], (x, y, z) => {
      x = (x + bounds) * (res / (bounds * 2));
      y = (y + bounds) * (res / (bounds * 2));
      z = (z + bounds) * (res / (bounds * 2));
      let p = x + z % tilesX * res + y * w + Math.floor(z / tilesX) * res * w;
      p *= 4;
      return read[p + 3] > 0 ? -1e-9 : 1;
    }, [[-bounds, -bounds, -bounds], [bounds, bounds, bounds]]);
    const ps = [], ids = [];
    const geometry = new BufferGeometry();
    mesh.positions.forEach((p) => {
      ps.push(p[0], p[1], p[2]);
    });
    mesh.cells.forEach((p) => ids.push(p[0], p[1], p[2]));
    geometry.setAttribute("position", new BufferAttribute(new Float32Array(ps), 3));
    geometry.setIndex(ids);
    return geometry;
  }
  computeSDF(width, height, tilesX, tilesY, bounds, shader) {
    const rt = new WebGLRenderTarget(width, height, { type: FloatType });
    const scn = new Scene();
    const cam = new OrthographicCamera();
    const tiles = tilesX * tilesY;
    let currentTile = 0;
    Object.assign(cam, { left: width / -2, right: width / 2, top: height / 2, bottom: height / -2 }).updateProjectionMatrix();
    cam.position.z = 2;
    const tileSize = width / tilesX;
    const geometry = new PlaneGeometry(tileSize, tileSize);
    while (currentTile++ < tiles) {
      const c = currentTile - 1;
      const [px, py] = [tileSize / 2 + c % tilesX * tileSize - width / 2, tileSize / 2 + Math.floor(c / tilesX) * tileSize - height / 2];
      const compPlane = new Mesh(geometry, new ShaderMaterial({
        uniforms: {
          res: { value: new Vector2(width, height) },
          tileNum: { value: c / (tilesX * tilesY - 1) },
          bounds: { value: bounds }
        },
        vertexShader: "varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}",
        fragmentShader: shader
      }));
      compPlane.position.set(px, py, 0);
      scn.add(compPlane);
    }
    this.renderer.setRenderTarget(rt);
    this.renderer.render(scn, cam);
    this.renderer.setRenderTarget(null);
    geometry.dispose();
    scn.traverse(function(object) {
      if (object.material !== void 0)
        object.material.dispose();
    });
    return rt;
  }
};
export {
  SDFGeometryGenerator
};
//# sourceMappingURL=three_addons_geometries_SDFGeometryGenerator__js.js.map
